---
title: "lab06_exercises"
format:
  html:
    embed-resources: true
editor: visual
---

## Load libraries

```{r}
library(tidyverse)  
library(modelr)     
library(splines)   
library(broom)      
library(ggrepel)  
```

## Load Data

```{r}
#| eval: true
borovecki_tibble <- readRDS("~/projects/group04_project/data/borovecki_tibble.rds")
```

## Clean Data

The `lm()` function uses a wide-data format where:

-   Each column is a gene

-   Each row is a sample denoted with its diagnosis: `0 = healthy`, `1 = disease`

-   Each cell contains the log2(expressionValue)

```{r}
borovecki_tibble <- borovecki_tibble |>
  pivot_wider(
    # Columns not to pivot
    id_cols = c(sample, diagnosis),
    
    # Columns to pivot
    names_from = gene,
    values_from = expressionValue
  ) |>
  
  # Create a new binary column that stores the clinical condition
  mutate(
    Diagnosis = case_when(
      diagnosis == "symptomatic" ~ 1,
      diagnosis == "control" ~ 0
    )
  ) |>
  dplyr::select(-c(diagnosis,sample)) |>
  relocate(Diagnosis, .before = 1)
```

## Individual Analysis

PMS1 was identified as a potential modifier gene in Hungington's disease, to study it, we applied a linear model (lm):

-   `(Intercept) = 56.82`: The average expression value of PMS1in healthy (0) patients

-   `Diagnosis = 33.17`: The average change in PMS1 expression when moving from the reference group (0) to the disease group (1).

```{r}
my_first_model <- lm(
  PMS1 ~ Diagnosis , 
  data = borovecki_tibble)

# Obtain coefficients of the model
coef(my_first_model)
```

I can also obtain these values by grouping by Diagnosis to compute the mean value of the gene PMS1

```{r}
borovecki_tibble |>
  group_by(Diagnosis) |>
  summarize(
    mu = mean(PMS1, na.rm = TRUE), # This works
  )
```

Both calculations show that PMS1 expression is up-regulated in the disease condition, it is interesting to see if this up-regulation is statistically significant at a level of significance of alfa = 0.05

To do so, we compute summary() within the linear model

```{r}
summary(my_first_model)
```

The gene is up-regulated in patients type 1 (positive slope)and the p-value is 0.00647 \< 0.05 which indicates that the effect is statistically significant at that alfa = 0.05.

## Complete Analysis for the 13041 genes

The complete analysis requires tidy data, to obtain it we will pivot the wide format

```{r}
borovecki_tibble_long <- borovecki_tibble  |> 
  pivot_longer(
    cols = -Diagnosis,
    names_to = "gene",
    values_to = "log2_expr_level"
  ) |>
  mutate(
    log2_expr_level = log2(log2_expr_level)
  )
```

Next, we will group the tidy data by `gene` and then add the `nest()` and `ungroup()` functions to your pipeline

```{r}
borovecki_tibble_long_nested <- borovecki_tibble_long |> 
  group_by(gene) |> 
  nest() |> 
  ungroup()
```

The result is a **`<tibble [13,039× 2]>`** where each row is a gene with a nested data frame that contains multiples rows with (diagnosis + log2_expr_level).

It's a tibble that has information of **13,039** genes for 2 variables (Diagnosis and log2Exp)

## Fitting models

Next, I want to fit a linear model to each gene, to do so, I have to let `R` know that I want to work per gene

```{r}
by_gene <- borovecki_tibble_long_nested |> 
  # The tibble is internally being group by the gene, works for certain functions
  # NEST() need groups
  group_by(gene)
```

I will now create a function that applies a linear model. Using `map()`, I'll apply this function to `borovecki_tibble_long_nested` *per* gene

-   The result is a **`<tibble [13,039× 3]>`** where each row is a gene with two nested data frames. The first one contains multiples rows with (diagnosis + log2_expr_level), whereas the second one contains the output of the linear function.

```{r}
# Define lm function
linear_model <- function(df) {
  lm(
  log2_expr_level ~ Diagnosis , 
  data = df)
}

# Apply lm function to each gene
borovecki_tibble_long_nested  <- borovecki_tibble_long_nested  |>  
  mutate(model_object = map(data, linear_model))
```

To get information from one specific gene

```{r}
borovecki_tibble_long_nested |>
  # My favourite gene!
  filter(gene == "MLH1") |> 
  
  pull(model_object) |> 
  # "pluck" the first element
  pluck(1) |>
  
  # The result of pluck, is a model object,
  #   upon which we can call the tidy function
  tidy(conf.int = TRUE,
       conf.level = 0.95)
```

**T13: Scroll a bit back to where we created the `model_object` and see if you can translate that into mapping the `tidy()` function to the `model_object` variable, thereby creating a new variable `model_object_tidy` - This is tricky, so do make sure to discuss in your group how this can be done!**

```{r}
tidy_data <- function(df) {
  df |>
  tidy(conf.int = TRUE,
       conf.level = 0.95)
  }

borovecki_tibble_long_nested  <- borovecki_tibble_long_nested  |>  
  mutate(model_object_tidy = map(model_object, tidy_data))

borovecki_tibble_long_nested
```

```{r}
# gravier_clean_aug_long_nested$model_object_tidy[[1]]
# gravier_clean_aug_long_nested |>
#   filter(gene == "g2E09") |> # Replace "g2E09" 
#   pull(model_object_tidy)
```

**T14: Create a `dplyr` pipeline and save the result in a new variable called `gravier_estimates`: Use the `unnest()` function to unpack the `model_object_tidy`**

```{r}
borovecki_estimates <- unnest(borovecki_tibble_long_nested, model_object_tidy)
borovecki_estimates
```

**T15: Then again, create a `dplyr` pipeline and save the result in a the same `gravier_estimates` variable: Subset the rows to only get the slope term and then choose variables as displayed below, finally end with un-grouping your data, as we no longer need the groups**

```{r}
borovecki_estimates <- borovecki_estimates |> 
  filter(term == "Diagnosis")|> 
  dplyr::select(gene, p.value, estimate, conf.low, conf.high) 
```

**T16: To your `gravier_estimates` dataset, add a variable `q.value`, which is the result of calling the `p.adjust()` function on your `p.value` variable and also add an indicator variable denoting if a given gene is significant or not**

```{r}
borovecki_estimates <- borovecki_estimates |> 
  mutate(q.value=p.adjust(p.value),
          is_significant = case_when(
            p.value >= 0.05 ~ "no",
            p.value < 0.05 ~ "yes"
    ))
```

**T17: Re-create this forest plot to finally reveal the results of your analysis**

```{r}
borovecki_estimates |> 
  filter(is_significant == "yes") |> 
  arrange(p.value) |> 
  slice_head(n = 30) |> 
  mutate(
    gene=fct_reorder(gene, estimate)
  ) |> 
  ggplot(aes(x=estimate, y=gene))+
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high)) +   
  geom_point() +
  labs(
    title = "Genes Associated with hungington disease",
    x = "Estimates (95%CIs)",
    y = NULL
  ) +
  theme_minimal() 
```

**T18: Re-create this volcano plot to finally reveal the results of your analysis**

```{r}
borovecki_data <- borovecki_estimates |> 
  mutate(
    significance = case_when(
      q.value < 0.05 ~ "Significant",
      q.value >= 0.05 ~ "Not Significant"
    ),
    lbl = case_when(
      q.value < 0.05 ~ gene,
      q.value >= 0.05 ~ ""
  ))

ggplot(borovecki_data, aes(x = estimate, y = -log10(p.value))) + 
  geom_point(aes(color=significance, label=lbl), alpha=0.5, size=1) +
  geom_text_repel(aes(color=significance, label = lbl), size = 2, max.overlaps = Inf) +
  labs(
    title = "Genes Associated with hungington disease",
    subtitle = "Genes highlighted in turquoise were significant after multiple testing correction",
    x = "Estimates",
    y = "-log10(p)"
  ) +
  theme_minimal() +
  theme(legend.position = "none") 
```
