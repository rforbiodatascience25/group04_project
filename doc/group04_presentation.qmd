---
title: "Group04 Presentation R4BDS"
author: "Eric Calaveras - Sol Escamilla - Beatriz García - Lucía López - Diego Medina"
format: revealjs
editor: visual
css: styles.css
echo: True
---

## Introduction

<div>

Dataset obtained from an article (Borovecki et al. 2005) about the correlation between the expression of different genes with the development of Huntington's disease.

Dataset content:

-   x: Probes IDs and gene expression values of each sample

-   y: Diagnosis (symptomatic, control)

The desired output to start working with the dataset is a tibble with tidy data:

1.  Each row is an observation
2.  Each column is a variable
3.  Each cell is a single value

</div>

## Materials and methods: Wrangling I: Initial tibble

<br>

With the data that we had, we created a tibble, where X is now a new column containing the samples from the microarray in order and Y is a new column containing the diagnosis of the patient in that respective sample.

Apart from that we have different columns for each sample representing all the genes from each one.

<br>

```{r eval=FALSE}
borovecki <- borovecki$x |>
  as_tibble() |>
  mutate(
    sample = row_number(), 
    .before = 1, 
    diagnosis = borovecki$y
  )
```

## Materials and methods: Wrangling II: Pivot_longer

<br>

We make use of the pivot function in order to get all the columns containing the different genes and including them all in the same column called probeID and placing the values from the different probe IDs into a new column called expressionValue.

<br>

```{r eval=FALSE}
borovecki <- borovecki |>
  pivot_longer(
    cols = ends_with("at"),
    names_to = "probeID", 
    values_to = "expressionValue",
    values_drop_na = TRUE
  )
```

## Bioconductor

<br>

The hgu133a.db package is useful to handle Affymetrix Human Genome U133A Microarrays as it allows us to do many different annotations.

In our case, thanks to the hgu133a.db package, we were able to annotate all the different probe IDs into real gene names so that the posterior work was done more easily.

<br>

```{r eval=FALSE}
#| message = FALSE
borovecki <- borovecki |>
  mutate(
    gene = mapIds(
      hgu133a.db, 
      keys=probeID, 
      keytype = "PROBEID", 
      column="SYMBOL",
      multiVals="first"
    )
  ) |>
  filter(!is.na(gene)) |>
  # I specify the package because AnnotationDbi also has a select function
  dplyr::select(-probeID)
```

## Linear Modelling (Obtaining gene-level data)

<br>

Let `R` know that we want to work per gene, to do that we define a Linear Model, the analysis requires:

-   Tidy data, to obtain it we will pivot the wide format

<br>

```{r eval=FALSE}
borovecki_tibble_long <- borovecki_tibble  |> 
  pivot_longer(
    cols = -Diagnosis,
    names_to = "gene",
    values_to = "log2_expr_level"
  ) |>
  mutate(
    log2_expr_level = log2(log2_expr_level)
  )
```

<br>

-   Group the tidy data by `gene` and then add the `nest()` and `ungroup()` functions to your pipeline

<br>

```{r eval=FALSE}
borovecki_tibble_long_nested <- borovecki_tibble_long |> 
  group_by(gene) |> 
  nest() |> 
  ungroup()
```

## Fitting the model

<br>

We created a function that applies a linear model. Applying the function `map()` to the `borovecki_tibble_long_nested` *per* gene.

The result is a **`<tibble [13,039× 3]>`** where each row is a gene with two nested data frames.

-   The first one contains multiples rows with (diagnosis + log2_expr_level)

-   The second one contains the output of the linear function.

    <br>

```{r eval=FALSE}
borovecki_tibble_long <- borovecki_tibble  |> 
  pivot_longer(
    cols = -Diagnosis,
    names_to = "gene",
    values_to = "log2_expr_level"
  ) |>
  mutate(
    log2_expr_level = log2(log2_expr_level)
  )
```

## Log2 transformation and categories

Almost all values are concentrated near zero, while one or a few values reach very high levels.This makes it nearly impossible to interpret the distribution or compare expression between genes. To address this, we apply a log2 transformation to the expression values.

This transformation serves five purposes:

1.  Normalise the distribution, reducing the influence of extremely large values.

2.  Spread out lower values, making subtle differences more interpretable.

3.  Better comparison between genes and a more normal-like distribution.

4.  We lose outliers influence, the variation becomes more uniform and the trend line becomes more stable.

5.  All this improvements reflect the biological trends more reliably.

## Visualization 1

```{r, echo=FALSE}


```

## Visualization 2

## Discussion

Gracias a usar todas estas herramientas hemos podido encontrar genes mas singnificativos e importantes en esta enfermedad
